% \iffalse meta-comment
%% =============================================================================
%%
%% string-diagrams <VERSION> (<DATE>)
%%
%% Copyright (C) 2023 by Paolo Brasolin <paolo.brasolin@gmail.com>
%% SPDX-License-Identifier: LPPL-1.3c
%%
%% =============================================================================
%%
%% This work may be distributed and/or modified under the
%% conditions of the LaTeX Project Public License, either version 1.3c
%% of this license or (at your option) any later version.
%% The latest version of this license is in
%%   https://www.latex-project.org/lppl.txt
%% and version 1.3c or later is part of all distributions of LaTeX
%% version 2008 or later.
%%
%% This work has the LPPL maintenance status `author-maintained'.
%%
%% The Current Maintainer of this work is Paolo Brasolin.
%%
%% This work consists of the files  README.md,
%%                                  string-diagrams.dtx,
%%                                  string-diagrams.ins,
%% and the derived files            string-diagrams.sty, and
%%                                  string-diagrams.pdf.
%%
%% =============================================================================
%%
%
% %%%=[ DRIVER ]================================================================
%
%<*driver>
\RequirePackage{snapshot}
\documentclass[a4paper,full]{l3doc}
\usepackage{parskip}

\NewDocumentCommand{\TikZ}{}{Ti\emph{k}Z}

\EnableCrossrefs
\CodelineIndex
\RecordChanges
\usepackage{string-diagrams}
\usetikzlibrary{calc}
\usetikzlibrary{fit}

\usepackage{tcolorbox}
\tcbuselibrary{listings, skins}

\lstset{
  language=[LaTeX]TeX,
  basicstyle=\MacroFont,
  columns=flexible,
  ^^A keywordstyle=\color{red},
  ^^A morekeywords={},
  texcsstyle=*\color{violet},
  moretexcs={node,draw,path,wires,foreach},
  breaklines=true,
}

\tcbset{
  codesample/.style={
    bicolor,
    colback=black!2!white,
    colbacklower=violet!2!white,
  size=minimal,
    left=1em, sidebyside gap=2em, right=1em,
    top=0.6em, bottom=0.6em,
  sidebyside,
    sidebyside adapt=right,
  },
  listing engine=listings,
  verbatim ignore percent=true,
}

\newenvironment{codesample}
  {\tcboutputlisting}
  {\endtcboutputlisting\tcbsidebyside[codesample]{\tcbuselistinglisting}{\tcbuselistingtext}}

\begin{document}
  \DocInput{\jobname.dtx}
  \PrintChanges
  \PrintIndex
\end{document}
%</driver>
%
% \fi
%
% \changes{0.1.0}{2023/05/31}{initial version}
% \changes{0.2.0}{2023/06/12}{make box ports configurable}
%
% \GetFileInfo{\jobname.sty}
%
% \title{^^A
%   The \pkg{\jobname} package^^A
%   \thanks{Thanks!}\\^^A
%   \fileinfo^^A
% }
%
% \author{^^A
%   Paolo Brasolin\\^^A
%   \texttt{\href{mailto:paolo.brasolin@gmail.com}{paolo.brasolin@gmail.com}}^^A
% }
%
% \date{\fileversion~(\filedate)}
%
% \maketitle
%
% ^^A=[ DOCUMENTATION ]=========================================================
%
% \begin{documentation}
%
% \begin{tcolorbox}[
%   colback=red!5!white,
%   colframe=red,
%   sharp corners,
%   boxrule=1pt,
% ]
% Please note this is the \href{https://semver.org/#spec-item-4}{major version zero}, meant for initial development: \emph{anything MAY change at any time}.
% The upside is that this is the best time to \href{https://github.com/paolobrasolin/string-diagrams#contributing}{contribute}!
% Of course you can also just keep the \texttt{sty} along with your code and not care at all.
% \end{tcolorbox}
%
%
% \section{Documentation}
%
% \begin{function}[added=2023-05-31,updated=2023-06-12]{/tikz/box}
%
%   You can draw a box by applying the \cmd{box} style to a node.
%
%   \begin{codesample}
%\begin{tikzpicture}
%  \node[box] {A};
%\end{tikzpicture}
%   \end{codesample}
%
%   You can position boxes using any standard \TikZ\ positioning techniques: they are just nodes.
%   Remember to set labels in order to reference them.
%
%   \begin{codesample}
%\begin{tikzpicture}
%  \node[box] (A) at (0,0) {A};
%  \node[box, right of=A] (B) {B};
%  \node[box] (C) at ($(B)+(2cm,1em)$) {C};
%\end{tikzpicture}
%   \end{codesample}
%
% \end{function}
%
% \begin{function}[added=2023-06-12]{
%   /pgf/box ports north,
%   /pgf/box ports east,
%   /pgf/box ports south,
%   /pgf/box ports west,
% }
%   \begin{syntax}
%     /pgf/box ports north=\meta{integer}
%     /pgf/box ports east=\meta{integer}
%     /pgf/box ports south=\meta{integer}
%     /pgf/box ports west=\meta{integer}
%   \end{syntax}
%
%   You can open up any number of ports on any side of a box using the appropriate key.
%   Then, you can refer to the opened ports by their index.
%
%   \begin{codesample}
%\begin{tikzpicture}[
%  marker/.style={circle, fill=white, inner sep=1pt, font=\ttfamily\tiny, text=violet},
%]
%
%\node[
%  box,
%  box ports north=2,
%  box ports east=3,
%  box ports south=4,
%  box ports west=5,
%] (A) {A};

%\node[box, box ports=2/3/4/5] (B) at (0,-2) {B};
%
%\node[box=2/3/4/5] (C) at (0,-4) {C};
%
%\foreach \name in {A,B,C}
%  \foreach \side/\count in {north/2,east/3,south/4,west/5}
%    \foreach \port in {1,...,\count}
%      \draw (\name.\side.\port) to ($(\name)!2!(\tikztostart)$) node [marker] {\port};
%
%\end{tikzpicture}
%   \end{codesample}
%
% \end{function}
%
% \begin{function}[added=2023-06-12]{
%   /pgf/box ports,
% }
%   \begin{syntax}
%     /pgf/box ports=\meta{integer}/\meta{integer}/\meta{integer}/\meta{integer}
%   \end{syntax}
%
%   The \texttt{box ports} key is a shortcut to set the number of ports on all sides at once.
%
%   \begin{codesample}
%\begin{tikzpicture}[
%  marker/.style={circle, fill, inner sep=1pt},
%]
%
%\node[box, box ports=1/2/3/4] (A) {A};
%
%\foreach \side/\n in {north/1,east/2,south/3,west/4}
%  \foreach \index in {1,...,\n}
%    \node[marker] at (A.\side.\index) {};
%
%\end{tikzpicture}
%   \end{codesample}
%
%   The same value can also be passed to the \texttt{box} key itself.
%
% \end{function}
%
% \begin{function}[added=2023-05-31,updated=2023-06-13]{\wires}
%   \begin{syntax}
%     \cs{wires}\oarg{\TikZ\ keys}\marg{connectivity}\marg{loose ends}
%   \end{syntax}
%
%   To connect boxes, you can use the \cmd\wires\ macro.
%   The first argument is \TikZ\ styling for the wires; the second argument is a nested dicionary specifying the connectivity; the third argument is a list of the loose ends to draw.
%   \texttt{box}es have the following anchors: \texttt{west}, \texttt{west.0}, \texttt{west.1},  \texttt{east}, \texttt{east.0}, and \texttt{east.1}.
%
%   \begin{codesample}
%\begin{tikzpicture}[scale=0.6]
%  \node[box=0/2/0/1] (A) at (-2, 0) {A};
%  \node[box=0/1/0/2] (B) at (+2, 0) {B};
%  \node[box=0/1/0/1] (C) at ( 0,+1) {C};
%  \node[box=0/1/0/1] (D) at ( 0,-1) {D};
%  \wires{
%    A = { east.1 = C.west
%        , east.2 = D.west
%        , west = @.west },
%    B = { east = @.east },
%    C = { east = B.west.1 },
%    D = { east = B.west.2 },
%  }
%\end{tikzpicture}
%   \end{codesample}
%
% \end{function}
%
% \begin{function}[added=2023-05-31]{/pgf/dot}
%
%   To split and join wires, you can use \texttt{dot}s and their anchors \texttt{north}, \texttt{east}, \texttt{south}, and \texttt{west}.
%   Remember to have fun with styling wires.
%
%   \DeleteShortVerb \"
%   \begin{codesample}
%\begin{tikzpicture}
%  \node[box=0/1/0/2] (A) at ( 0,+1) {A};
%  \node[box=0/2/0/1] (B) at ( 0,-1) {B};
%  \node[dot] (x) at (+1, 0) {};
%  \node[dot] (y) at (-1, 0) {};
%  \wires[looseness=1.5,-stealth]{
%    @.east = [red]{
%      [dashed] B.east.2,
%      x.east },
%    @ = [green]{
%      west = [dashed, ultra thick]{
%        ["f"]A.west.1,
%        [red]y.west }, },
%    A = { east.1 = x.north },
%    B = { east.1 = x.south },
%    y = { north = A.west.2
%        , south = B.west },
%  }
%\end{tikzpicture}
%   \end{codesample}
%   \MakeShortVerb \"
%
% \end{function}
%
% That's it. This is the package, for now.
%
% \end{documentation}
%
% ^^A=[ PACKAGE ]===============================================================
%
% \begin{implementation}
%
% \section{Implementation}
%
% Open the \pkg{DocStrip} guards and set the internal namespace prefix (as per \LaTeX3 \pkg{DocStrip} convention).
%    \begin{macrocode}
%<*package>
%<@@=stridi>
%    \end{macrocode}
%
% Load the essential support (\pkg{expl3}) \enquote{up-front}.
%
%    \begin{macrocode}
\RequirePackage{expl3}[2023/05/11]
\RequirePackage{tikz}[2023/01/15]
%    \end{macrocode}
%
% Identify the package and give the over all version information.
%    \begin{macrocode}
\ProvidesExplPackage
  {string-diagrams}
  {<DATE>}
  {<VERSION>}
  {Draw string diagrams using TikZ}
%    \end{macrocode}
%
%  \begin{macro}{
%    /pgf/box ports north,
%    /pgf/box ports east,
%    /pgf/box ports south,
%    /pgf/box ports west,
%    /pgf/box ports,
%  }
%
%    Define high level keys to configure the number of ports on each side.
%    \begin{macrocode}
\pgfkeys{
  /pgf/box~ports~north/.initial=1,
  /pgf/box~ports~east/.initial=1,
  /pgf/box~ports~south/.initial=1,
  /pgf/box~ports~west/.initial=1,
  /pgf/box~ports/.style~args={#1/#2/#3/#4}{
    /pgf/box~ports~north=#1,
    /pgf/box~ports~east=#2,
    /pgf/box~ports~south=#3,
    /pgf/box~ports~west=#4,
  },
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\@@_intersect_hv_lines_through:NN}
%    Calculates the intersection of two lines parallel to axes passing through given points on the plane.
%    \begin{arguments}
%      \item Point through which the vertical line passes
%      \item Point through which the horizontal line passes
%    \end{arguments}
%    \begin{macrocode}
\cs_new:Nn \@@_intersect_hv_lines_through:NN {
  \pgfextractx { \pgf@xa } { #1 }
  \pgfextracty { \pgf@ya } { #2 }
  \pgfpoint { \pgf@xa } { \pgf@ya }
}
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\@@_subdivide_segment:nNNNNN}
%   Defines macros numbering equally spaced points on a segment.
%   \begin{arguments}
%     \item Base namespace
%     \item Points count
%     \item Point containing the x coordinate of the starting point
%     \item Point containing the y coordinate of the starting point
%     \item Point containing the x coordinate of the ending point
%     \item Point containing the y coordinate of the ending point
%   \end{arguments}
%    \begin{macrocode}
\cs_new:Nn \@@_subdivide_segment:nNNNNN {
  \int_step_inline:nnnn { #2 } { -1 } { 1 } {
    \cs_if_exist:cTF
      { #1.##1 }
      { \prg_break: }
      { \prg_do_nothing: }
    \cs_new_nopar:cpn
      { #1.##1 }
      {
        \pgfmathdivide
          { 2 * ##1 - 1 }
          { 2 * #2 }
        \pgfpointlineattime
          { \pgfmathresult }
          { \@@_intersect_hv_lines_through:NN { #3 } { #4 } }
          { \@@_intersect_hv_lines_through:NN { #5 } { #6 } }
      }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{box}
%   \changes{0.2.0}{2023/06/12}{make ports configurable through \TikZ\ keys}
%
%   Define a rectangular shape with configurable ports.
%    \begin{macrocode}
\pgfdeclareshape{box}{

  % Inherit all the structure of rectangle
  \inheritsavedanchors[from=rectangle]
  \clist_map_inline:nn
    {
      north~west,  north, north~east,
            west, center,       east,
        mid~west,    mid,   mid~east,
       base~west,   base,  base~east,
      south~west,  south, south~east,
    }
    { \inheritanchor[from=rectangle]{#1} }
  \inheritanchorborder[from=rectangle]
  \inheritbackgroundpath[from=rectangle]

  % Dump port counts into saved macros
  \savedmacro\portsnorth
    {\pgfmathtruncatemacro\portsnorth{\pgfkeysvalueof{/pgf/box~ports~north}}}
  \savedmacro\portseast
    {\pgfmathtruncatemacro\portseast{\pgfkeysvalueof{/pgf/box~ports~east}}}
  \savedmacro\portssouth
    {\pgfmathtruncatemacro\portssouth{\pgfkeysvalueof{/pgf/box~ports~south}}}
  \savedmacro\portswest
    {\pgfmathtruncatemacro\portswest{\pgfkeysvalueof{/pgf/box~ports~west}}}

  % Add ports definitions to shape definition
  \expandafter\pgfutil@g@addto@macro\csname pgf@sh@s@box\endcsname{
    \@@_subdivide_segment:nNNNNN { pgf@anchor@box@north } { \portsnorth }
      { \southwest } { \northeast } { \northeast } { \northeast }
    \@@_subdivide_segment:nNNNNN { pgf@anchor@box@east } { \portseast }
      { \northeast } { \northeast } { \northeast } { \southwest }
    \@@_subdivide_segment:nNNNNN { pgf@anchor@box@south } { \portssouth }
      { \southwest } { \southwest } { \northeast } { \southwest }
    \@@_subdivide_segment:nNNNNN { pgf@anchor@box@west } { \portswest }
      { \southwest } { \northeast } { \southwest } { \southwest }
  }

}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{/pgf/box}
%   \changes{0.2.0}{2023/06/12}{acts as a shortcut for setting port counts}
%
%   Define style to draw boxes.
%    \begin{macrocode}
\ExplSyntaxOff
\tikzset{
  box/.default={0/0/0/0},
  box/.style args={#1}{
    shape=box,
    draw,
    inner sep=.5em,
    minimum width=2em,
    minimum height=2em,
    execute at begin node=$,
    execute at end node=$,
    /pgf/box ports=#1,
  },
}
\ExplSyntaxOn
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{/tikz/dot}
%
%   Define style to draw dots.
%    \begin{macrocode}
\ExplSyntaxOff
\tikzset{
  dot/.style={
    shape=circle,
    fill,
    inner sep=0,
    minimum width=0.4em,
  },
}
\ExplSyntaxOn
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_calctarget:nnnn}
%   Performs the core calculation for \macro{\@@_anchors_to_proj:Nnnnn}.
%   The result is stored in the internal \texttt{pgf} variables.
%   \begin{arguments}
%     \item source node
%     \item source anchor
%     \item target node (can be boundary)
%     \item target anchor
%   \end{arguments}
%    \begin{macrocode}
\cs_new:Nn \@@_calctarget:nnnn {
  \pgfpointanchor{#1}{#2} \pgf@xa=\pgf@x \pgf@ya=\pgf@y
  \pgfpointanchor{#3}{#4} \pgf@xb=\pgf@x \pgf@yb=\pgf@y
  \regex_match_case:nn
  {
    { \A north ; north \b } { \pgfpoint { \pgf@xa } { \pgf@yb } }
    { \A north ; south \b } { \pgfpoint { \pgf@xa } { \pgf@yb } }
    { \A south ; north \b } { \pgfpoint { \pgf@xa } { \pgf@yb } }
    { \A south ; south \b } { \pgfpoint { \pgf@xa } { \pgf@yb } }
    { \A north ; east  \b } { \pgfpoint { \pgf@xa+.618*(\pgf@yb-\pgf@ya) } { \pgf@yb } }
    { \A south ; east  \b } { \pgfpoint { \pgf@xa-.618*(\pgf@yb-\pgf@ya) } { \pgf@yb } }
    { \A north ; west  \b } { \pgfpoint { \pgf@xa-.618*(\pgf@yb-\pgf@ya) } { \pgf@yb } }
    { \A south ; west  \b } { \pgfpoint { \pgf@xa+.618*(\pgf@yb-\pgf@ya) } { \pgf@yb } }
    { \A east  ; east  \b } { \pgfpoint { \pgf@xb } { \pgf@ya } }
    { \A east  ; west  \b } { \pgfpoint { \pgf@xb } { \pgf@ya } }
    { \A west  ; east  \b } { \pgfpoint { \pgf@xb } { \pgf@ya } }
    { \A west  ; west  \b } { \pgfpoint { \pgf@xb } { \pgf@ya } }
    { \A east  ; north \b } { \pgfpoint { \pgf@xb } { \pgf@ya+.618*(\pgf@xb-\pgf@xa) } }
    { \A west  ; north \b } { \pgfpoint { \pgf@xb } { \pgf@ya-.618*(\pgf@xb-\pgf@xa) } }
    { \A east  ; south \b } { \pgfpoint { \pgf@xb } { \pgf@ya-.618*(\pgf@xb-\pgf@xa) } }
    { \A west  ; south \b } { \pgfpoint { \pgf@xb } { \pgf@ya+.618*(\pgf@xb-\pgf@xa) } }
  } { #4 ; #2 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_anchor_to_angle:Nnn}
%   Calculates in/out angle given a node/anchor pair.
%   Accounts for when the node is the boundary.
%   The result is stored in the given variable.
%   \begin{arguments}
%     \item token list variable
%     \item node
%     \item anchor
%   \end{arguments}
%    \begin{macrocode}
\cs_new:Nn \@@_anchor_to_angle:Nnn {
  \regex_match_case:nnTF
    {
      { \A north \b } { \int_set:Nn \l_tmpa_int {  90 } }
      { \A east  \b } { \int_set:Nn \l_tmpa_int {   0 } }
      { \A south \b } { \int_set:Nn \l_tmpa_int { -90 } }
      { \A west  \b } { \int_set:Nn \l_tmpa_int { 180 } }
    }
    { #3 }
    {
      \str_if_eq:nnTF { @ } { #2 }
        { \int_sub:Nn \l_tmpa_int { 180 } } { }
      \tl_set:Nf #1 { \int_use:N \l_tmpa_int }
    }
    { \tl_clear:N #1 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_anchors_to_proj:Nnnnn}
%   Calculates a target point given two node/anchor pairs.
%   The first pair can be on the boundary.
%   The result is stored in the given token list variable.
%   \begin{arguments}
%     \item token list variable
%     \item source node
%     \item source anchor
%     \item target node
%     \item target anchor
%   \end{arguments}
%    \begin{macrocode}
\cs_new:Nn \@@_anchors_to_proj:Nnnnn {
  \regex_match_case:nn
    {
      { \A @ \. } {
        \@@_calctarget:nnnn { #4 } { #5 } { #2 } { #3 }
        \pgfgetlastxy { \l_tmpa_dim } { \l_tmpb_dim }
        \tl_gset:Nn #1 { \l_tmpa_dim, \l_tmpb_dim }
      }
      { } { \tl_gset:Nn #1 { #2.#3 } }
    }
    { #2.#3 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_@@_styles_tl,\l_@@_oangle_tl,\l_@@_iangle_tl,\l_@@_source_tl,\l_@@_target_tl}
%   Initialize scratch variables required by \cmd{\@@_draw_wire:nnnnn}.
%    \begin{macrocode}
\tl_new:N \l_@@_styles_tl
\tl_new:N \l_@@_oangle_tl
\tl_new:N \l_@@_iangle_tl
\tl_new:N \l_@@_source_tl
\tl_new:N \l_@@_target_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\@@_draw_wire:nnnnn}
%   Draws a wire.
%   \begin{arguments}
%     \item \TikZ\ keys
%     \item source node
%     \item source anchor
%     \item target node
%     \item target anchor
%   \end{arguments}
%    \begin{macrocode}
\cs_new:Nn \@@_draw_wire:nnnnn {
  \tl_set:Nn                \l_@@_styles_tl { #1 }
  \@@_anchor_to_angle:Nnn   \l_@@_oangle_tl { #2 } { #3 }
  \@@_anchor_to_angle:Nnn   \l_@@_iangle_tl { #4 } { #5 }
  \@@_anchors_to_proj:Nnnnn \l_@@_source_tl { #2 } { #3 } { #4 } { #5 }
  \@@_anchors_to_proj:Nnnnn \l_@@_target_tl { #4 } { #5 } { #2 } { #3 }

  \use:x {
    \exp_not:N \path
      [out={\tl_use:N \l_@@_oangle_tl},
       in= {\tl_use:N \l_@@_iangle_tl}]
           (\tl_use:N \l_@@_source_tl)
      edge [\tl_use:N \l_@@_styles_tl]
           (\tl_use:N \l_@@_target_tl);
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_draw_boundary:nn}
%   Creates the boundary node.
%    \begin{macrocode}
\cs_new:Nn \@@_draw_boundary: {
  \node [%draw, box=2/2/0/1, dashed, red,
    name=@, node~contents={},
    fit={
      ([shift={(+2em,+1em)}]current~bounding~box.north~east)
      ([shift={(-2em,-1em)}]current~bounding~box.south~west)
    },
  ];
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_split_node_anchor:NNn}
%   Parses a token list into a node/anchor pair.
%   \begin{arguments}
%     \item token list variable to store node
%     \item token list variable to store anchor
%     \item token list to be parsed
%   \end{arguments}
%    \begin{macrocode}
\cs_new:Nn \@@_split_node_anchor:NNn {
  \regex_extract_once:nnN { ([^\.])* \.? (.*) } { #3 } \l_tmpa_seq
  \seq_pop:NN \l_tmpa_seq \l_tmpa_tl  % discard match
  \seq_pop:NN \l_tmpa_seq #1          % keep 1st matching group (node)
  \seq_pop:NN \l_tmpa_seq #2          % keep 2nd matching group (anchor)
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\exp_args:NVnnVV, \exp_args:NVVVVV}
%   These helpers are required by \cmd{\@@_adj_map_function:nnN}.
%    \begin{macrocode}
\exp_args_generate:n { VnnVV }
\exp_args_generate:n { VVVVV }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_strip_optional_keylist:NNn}
%   TODO
%   \begin{arguments}
%     \item TODO
%   \end{arguments}
%    \begin{macrocode}
\cs_new:Nn \@@_strip_optional_keylist:NNn {
  \regex_extract_once:nnN
    {
      \A
      (?: \[ (.*?) \] )?
      \{? (.+?) \}?
      \Z
    } { #3 } \l_tmpb_seq

  \seq_pop_right:NN \l_tmpb_seq #2 % keep 2nd matching group
  \seq_pop_right:NN \l_tmpb_seq #1 % keep 1st matching group
}
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_@@_styles_seq,\l_@@_src_n_tl,\l_@@_src_a_tl,\l_@@_tgt_n_tl,\l_@@_tgt_a_tl}
%   Initialize scratch variables required by \cmd{\@@_adj_map_function:nnN}.
%    \begin{macrocode}
\seq_new:N \l_@@_styles_seq
\tl_new:N  \l_@@_src_n_tl
\tl_new:N  \l_@@_src_a_tl
\tl_new:N  \l_@@_tgt_n_tl
\tl_new:N  \l_@@_tgt_a_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\@@_adj_map_function:nnN}
%   Unrolls the nested dictionary of adjacencies into pairs and maps a function over them.
%   The given list of \TikZ\ keys is passed through to the function.
%   \begin{arguments}
%     \item \TikZ\ keys to pass through
%     \item nested dictionary of adjacencies
%     \item function to be mapped over pairs
%   \end{arguments}
%    \begin{macrocode}
\cs_new:Nn \@@_adj_map_function:nnN {
  \seq_clear:N \l_@@_styles_seq
  \seq_put_right:Nn \l_@@_styles_seq { #1 }

  \tl_set_rescan:Nnn
    \l_tmpb_tl
    {
      \char_set_catcode_group_begin:N [
      \char_set_catcode_group_end:N ]
    }
    { #2 }

  \exp_args:NNV \prop_set_from_keyval:Nn \l_tmpa_prop \l_tmpb_tl
  \prop_map_inline:Nn \l_tmpa_prop {
    \regex_match:nnTF { \. } { ##1 }
      {
        % KEY: <node>.<anchor>
        % VAL: [...]{ [...]<node>.<anchor>, ... }
        \@@_strip_optional_keylist:NNn \l_tmpa_tl \l_tmpb_tl { ##2 }
        \seq_put_right:NV \l_@@_styles_seq \l_tmpa_tl
        \clist_set:NV \l_tmpa_clist \l_tmpb_tl
        \clist_map_inline:Nn \l_tmpa_clist {
          \@@_split_node_anchor:NNn \l_@@_src_n_tl \l_@@_src_a_tl { ##1 }
          \@@_strip_optional_keylist:NNn \l_tmpa_tl \l_tmpb_tl { ####1 }
          \seq_put_right:NV \l_@@_styles_seq \l_tmpa_tl
          \exp_args:NNNV \@@_split_node_anchor:NNn \l_@@_tgt_n_tl \l_@@_tgt_a_tl \l_tmpb_tl
          \tl_set:Nx \l_tmpa_tl { \seq_use:Nn \l_@@_styles_seq {,} } % NOTE: items are not expanded in an x
          \exp_args:NNnV \tl_set_rescan:Nnn \l_tmpa_tl {} \l_tmpa_tl
          \exp_args:NVVVVV #3
            \l_tmpa_tl
            \l_@@_src_n_tl \l_@@_src_a_tl
            \l_@@_tgt_n_tl \l_@@_tgt_a_tl
          \seq_pop_right:NN \l_@@_styles_seq \l_tmpb_tl
        }
        \seq_pop_right:NN \l_@@_styles_seq \l_tmpb_tl
      }
      {
        % KEY: <node>
        % VAL: [...]{ <anchor> = [...]{ [...]<node>.<anchor>, ... }, ... }
        \@@_strip_optional_keylist:NNn \l_tmpa_tl \l_tmpb_tl { ##2 }
        \seq_put_right:NV \l_@@_styles_seq \l_tmpa_tl
        \exp_args:NNV \prop_set_from_keyval:Nn \l_tmpb_prop \l_tmpb_tl
    \prop_map_inline:Nn \l_tmpb_prop {
          \@@_strip_optional_keylist:NNn \l_tmpa_tl \l_tmpb_tl { ####2 }
          \seq_put_right:NV \l_@@_styles_seq \l_tmpa_tl
          \clist_set:NV \l_tmpa_clist \l_tmpb_tl
          \clist_map_inline:Nn \l_tmpa_clist {
            % NOTE: we skip assigning \l_@@_src_n_tl = ##1 and \l_@@_src_a_tl = ####1
            \@@_strip_optional_keylist:NNn \l_tmpa_tl \l_tmpb_tl { ########1 }
            \seq_put_right:NV \l_@@_styles_seq \l_tmpa_tl
            \exp_args:NNNV \@@_split_node_anchor:NNn \l_@@_tgt_n_tl \l_@@_tgt_a_tl \l_tmpb_tl
            \tl_set:Nx \l_tmpa_tl { \seq_use:Nn \l_@@_styles_seq {,} } % NOTE: items are not expanded in an x
            \exp_args:NNnV \tl_set_rescan:Nnn \l_tmpa_tl {} \l_tmpa_tl
            \exp_args:NVnnVV #3
              \l_tmpa_tl
              { ##1 } { ####1 }
              \l_@@_tgt_n_tl \l_@@_tgt_a_tl
            \seq_pop_right:NN \l_@@_styles_seq \l_tmpb_tl
          }
          \seq_pop_right:NN \l_@@_styles_seq \l_tmpb_tl
        }
        \seq_pop_right:NN \l_@@_styles_seq \l_tmpb_tl
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\wires}
%   \changes{0.2.1}{2023/06/13}{now correctly handles optional style parameter}
%   Define our superstar.
%    \begin{macrocode}
\NewDocumentCommand{\wires}{ O{} m }
{
  \@@_draw_boundary:
  \@@_adj_map_function:nnN
    { #1 } { #2 } \@@_draw_wire:nnnnn
}
%    \end{macrocode}
% \end{macro}
%
% Close the \pkg{DocStrip} guards and call it a day.
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
